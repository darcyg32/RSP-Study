#Chapter_9 
- An important idea to speed up search is to explore your best options before the less promising choices.
	- In the `backtrack` implementation presented [[9.1 - Backtracking|earlier]], the search order was determined by the sequence of elements generated by the `construct_candidates` routine.
		- Items near the front of the candidates array were tried before those further back.
- A good candidate ordering can have a very powerful effect on the time to solve the problem.

- The examples so far in this chapter have focused on *existential* search problems, where we look for a single solution (or all solutions) satisfying a given set of constraints.
- *Optimization problems* seek the solution with the lowest or highest value of some objective function.
	- A simple strategy to deal with optimization problems is to construct all possible solutions, and then report the one that scores best by the optimization criterion.
		- But this can be expensive.
	- Much better would be to generate solutions in order from best to worst, and report the best as soon as we can prove it is the best.

- *Best-first search*, also called *branch and bound*, assigns a cost to every partial solution we have generated.
- We use a priority queue (named `q` below) to keep track of these partial solutions by cost, so the most promising partial solution can be easily identified and expanded.
	- As in backtracking, we explore the next partial solution by testing if it `is_a_solution` and called `process_solution` if it is.
	- We identify all ways to expand this partial solution by calling `construct_candidates`, each of which gets inserted into the priority queue with its associated cost.
- A generic best-first search, which we apply to the traveling salesman problem (TSP), is implemented as follows:

```C
void branch_and_bound(tsp_solution* s, tsp_instance* t) {
	int c[MAXCANDIDATES];    // Candidates for next position
	int nc;                  // Next position candidate count
	int i;                   // Counter

	first_solution(&best_solution, t);
	best_cost = solution_cost(&best_solution, t);
	initialize_solution(s, t);
	extend_solution(s, t, 1);
	pq_init(&q);
	pq_insert(&q, s);

	while (top_pq(&q).cost < best_cost) {
		*s = extract_min(&q);
		if (is_a_solution(s, s->n, t)) {
			process_solution(s, s->n, t);
		} else {
			construct_candidates(s, s->n + 1, t, c, &nc);
			for (i = 0; i < nc; i++) {
				extend_solution(s, t, c[i]);
				pq_insert(&q, s);
				contract_solution(s, t);
			}
		}
	}
}
```

- The `extend_solution` and `contract_solution` routines handle the bookkeeping of creating and pricing the partial solutions associated with each new candidate:

```C
void extend_solution(tsp_solution* s, tsp_instance* t, int v) {
	s->n++;
	s->p[s->n] = v;
	s->cost = partial_solution_lb(s, t);
}

void contract_solution(tsp_solution* s, tsp_instance* t) {
	s->n--;
	s->cost = partial_solution_lb(s, t);
}
```

- What should be the cost of a partial solution?
	- There are $(n-1)!$ circular permutations on *n* points, so we can represent each tour as an *n*-element permutation starting with 1 so there are no repetitions.
	- Partial solutions construct a prefix of the tour starting with vertex $v_1$, so a natural cost function might be the sum of the edge weights on this prefix source.
		- An interesting property of such a cost function is that is serves as a *lower bound* on the cost of any expanded tour, assuming that all edge weights are positive.

- But does the first full solution from a best-first search have to be an optimal solution?
	- No, not necessarily.
	- There was certainly no cheaper partial solution available when we pulled it off the priority queue.
	- But extending this partial solution came with a cost, that of the next edge we added to this tour.
	- It is certainly possible that a slightly more costly partial tour might be finishable using a less-expensive next edge, thus producing a better solution.

- Thus, to get the global optimum, we must continue to explore the partial solutions coming off the priority queue until they are more expensive than the best solution we already know about.
	- Note that this requires that the cost function for partial solutions be a lower bound on the cost of an optimal solution.
	- Otherwise, there might be something deeper in the queue that would expand to a better solution.
		- That would leave us with no choice but to expand everything on the priority queue completely to be sure we found the right solution.